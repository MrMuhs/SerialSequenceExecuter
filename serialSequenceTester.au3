; own include stuff
#include <StringConstants.au3>
#include 'CommMG.au3' ;or if you save the commMg.dll in the @scripdir use #include @SciptDir & '\commmg.dll'
#include <Array.au3>
#include <File.au3>
#include <FileConstants.au3>
#include <MsgBoxConstants.au3>
#include <ComboConstants.au3>
#include <GuiComboBox.au3>
#include <ColorConstants.au3>
#include <Timers.au3>

; gui part form koda export:
#include <ButtonConstants.au3>
#include <EditConstants.au3>
#include <GUIConstantsEx.au3>
#include <StaticConstants.au3>
#include <WindowsConstants.au3>
#Region ### START Koda GUI section ### Form=Form1.kxf
$Form1 = GUICreate("Form1", 629, 516, 308, 427)
$Edit1 = GUICtrlCreateEdit("", 8, 32, 489, 409)
GUICtrlSetData(-1, StringFormat("##some comment about what magic happens now\r\n#startnewlog\r\n#sleep#~#1000\r\nls /usr/bin/\r\n#sleep#~#1000\r\n#waitfor#some string to appear in serial\r\n#writemarker#~#some static marker text\r\nls /tmp\r\n#sleep#~#1000\r\n#exit"))
GUICtrlSetResizing(-1, $GUI_DOCKLEFT+$GUI_DOCKRIGHT+$GUI_DOCKTOP+$GUI_DOCKBOTTOM)
$btnOpenSerial = GUICtrlCreateButton("Open serial", 504, 32, 115, 25)
GUICtrlSetResizing(-1, $GUI_DOCKRIGHT+$GUI_DOCKTOP+$GUI_DOCKWIDTH+$GUI_DOCKHEIGHT)
$btnCloseSerial = GUICtrlCreateButton("Close serial", 504, 64, 115, 25)
GUICtrlSetResizing(-1, $GUI_DOCKRIGHT+$GUI_DOCKTOP+$GUI_DOCKWIDTH+$GUI_DOCKHEIGHT)
$btnLoadCommands = GUICtrlCreateButton("Load commands", 504, 208, 115, 25)
GUICtrlSetResizing(-1, $GUI_DOCKRIGHT+$GUI_DOCKWIDTH+$GUI_DOCKHEIGHT)
$btnStartExecute = GUICtrlCreateButton("Start execute", 504, 384, 115, 25)
GUICtrlSetResizing(-1, $GUI_DOCKRIGHT+$GUI_DOCKBOTTOM+$GUI_DOCKWIDTH+$GUI_DOCKHEIGHT)
$btnStopExecute = GUICtrlCreateButton("Stop execute", 504, 416, 115, 25)
GUICtrlSetResizing(-1, $GUI_DOCKRIGHT+$GUI_DOCKBOTTOM+$GUI_DOCKWIDTH+$GUI_DOCKHEIGHT)
$Label1 = GUICtrlCreateLabel("Command sequence", 8, 8, 101, 17)
$btnSaveCommands = GUICtrlCreateButton("Save commands", 504, 240, 115, 25)
GUICtrlSetResizing(-1, $GUI_DOCKRIGHT+$GUI_DOCKWIDTH+$GUI_DOCKHEIGHT)
$btnNewLog = GUICtrlCreateButton("Start new logfile", 504, 96, 115, 25)
$Label2 = GUICtrlCreateLabel("Serial Info:", 8, 448, 54, 17)
$Label3 = GUICtrlCreateLabel("Logfile Info:", 8, 472, 59, 17)
$lblSerialInfo = GUICtrlCreateLabel("COM 2 / 115200 / 8 Bit / 1 Stop / 0 Parity / No flow", 72, 448, 547, 17)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT+$GUI_DOCKRIGHT+$GUI_DOCKBOTTOM)
$lblLogInfo = GUICtrlCreateLabel("20200227_1250_serial.log / written 47484 bytes", 72, 472, 547, 17)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT+$GUI_DOCKRIGHT+$GUI_DOCKBOTTOM)
$Label4 = GUICtrlCreateLabel("Execution:", 8, 496, 54, 17)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT+$GUI_DOCKRIGHT+$GUI_DOCKBOTTOM)
$lblExecution = GUICtrlCreateLabel("Loops 0 / Command 0 of 0", 72, 496, 547, 17)
GUICtrlSetResizing(-1, $GUI_DOCKLEFT+$GUI_DOCKRIGHT+$GUI_DOCKBOTTOM)
GUISetState(@SW_SHOW)
#EndRegion ### END Koda GUI section ###

; own initilizations
$isAbored = 0
$logfileName = ""
$logfileWrittenData = 0
$markerNumber = 0

$currentSerialIsConnected = False
$currentSerialSetPort = 0
$currentSerialBautrate = 0
$currentSerialDatabits = 0
$currentSerialParity = 0
$currentSerialStopbit = 0
$currentSerialFlowbit = 0
$isExecutionRunning = 0
Global $currentCommandsList[0]
$currentCommandIndex = 0
$currentLoopCounter = 0

; if we just loop thru the commands in a while loop with sleeps and stuff, the GUI thread gets blocked,
; and it is not possible to press stop button. Therefor we need to loop and dummy event thru the GUI
; event system, which causes the next event to execute.
Global $g_idUserDummy
$g_idUserDummy = GUICtrlCreateDummy()
GUICtrlSetOnEvent(-1, "executeNextCommandFromSequence")

Dim $FlowType[3] = ["Hardware (RTS, CTS)", "XOnXoff", "NONE"]
Dim $ParityType[5] = ["odd", "even", "none", "Mark", "Space"]

Opt("WINTITLEMATCHMODE", 3)
HotKeySet("{ESC}", "AllDone")
$maintitle = "SerialSequenceTester (CommVersion: " & _CommGetVersion(1) & ")" ; we need to store this to switch between setPort and main form
$setporttitle = "SerialSequenceTester - Open Serial Port"
WinSetTitle($Form1, "", $maintitle)
_CommClearOutputBuffer()
_CommClearInputBuffer()

; bind the gui event handlers here
Opt("GUIOnEventMode", 1)
GUISetOnEvent($GUI_EVENT_CLOSE, "AllDone")
GUICtrlSetOnEvent($btnOpenSerial, "btnOpenSerialFunc")
GUICtrlSetOnEvent($btnCloseSerial, "btnCloseSerialFunc")
GUICtrlSetOnEvent($btnNewLog, "btnNewLogFunc")
GUICtrlSetOnEvent($btnLoadCommands, "btnLoadCommandsFunc")
GUICtrlSetOnEvent($btnSaveCommands, "btnSaveCommandsFunc")
GUICtrlSetOnEvent($btnStartExecute, "btnStartExecuteFunc")
GUICtrlSetOnEvent($btnStopExecute, "btnStopExecuteFunc")

updateLogfileName()
alignButtonState()
GUICtrlSetData($lblSerialInfo, "--- closed ---")
_CommClearOutputBuffer()
_CommClearInputBuffer()

; just the main loop as it is generated by koda
While 1
	$nMsg = GUIGetMsg()
	Switch $nMsg
		Case $GUI_EVENT_CLOSE
         Exit
   EndSwitch
   Sleep(10)
WEnd

; all the required functions below this
Func AllDone()
   If WinActive($maintitle) Then
      _Commcloseport(true)
      MsgBox(0, 'Port closed', 'Have a good one!')
      Exit
   EndIf
EndFunc

Func updateLogfileName($customTag = "serial")
   $logfileName = @YEAR & @MON & @MDAY & "_" & @HOUR & @MIN & @SEC & "_" & $customTag & ".log"
   $logfileWrittenData = 0
   updateLogfileNameLabel()
EndFunc

Func updateLogfileNameLabel()
   GUICtrlSetData($lblLogInfo, $logfileName & " / " & $logfileWrittenData & " bytes")
EndFunc

Func updateCurrentSerialLabel()
   ; somehting like "COM 2 / 115200 / 8 Bit / 1 Stop / 0 Parity / No flow"
   GUICtrlSetData($lblSerialInfo, "COM " & $currentSerialSetPort & " / " & $currentSerialBautrate & " / " & $currentSerialDatabits & " Bits / " & $ParityType[$currentSerialParity] & " Parity / " & $currentSerialStopbit & " Stop / " & $FlowType[$currentSerialFlowbit] & " flow")
EndFunc

Func updateCurrentStatisticLabel()
   ; Loops 42 / Command 4 of 55
   GUICtrlSetData($lblExecution, "Loops done " & $currentLoopCounter & " / Command " & $currentCommandIndex & " of " & UBound($currentCommandsList, 1))
EndFunc

Func AppendLineLogFile($lineToAppend)
   ; Open the file for writing (append to the end of a file) and store the handle to a variable.
   Local $hFileOpen = FileOpen($logfileName, $FO_APPEND)
   If $hFileOpen = -1 Then
       MsgBox($MB_SYSTEMMODAL, "", "An error occurred while writing the log file.")
       Return False
   EndIf
   $lineToAppend = StringReplace($lineToAppend, ""& @CR & @CR, "" & @CR)
   $logfileWrittenData = $logfileWrittenData + StringLen($lineToAppend)
   updateLogfileNameLabel()
   FileWrite($hFileOpen, $lineToAppend)
   FileClose($hFileOpen)
EndFunc

Func ReadSerialLineToEnd()
	While 1
		$instr = _CommGetString()
      If $instr <> '' Then
			AppendLineLogFile($instr)
		Else
			Sleep(50) ; give him a small sleep to not just while-peek the CPU
			ExitLoop
		EndIf
	WEnd
EndFunc

Func waitUntilYouGet($waitForString)
	While 1
      $instr = _CommGetString()
      If $instr <> '' Then
         AppendLineLogFile($instr)
			If StringInStr($instr, $waitForString) >= 1 Then
				ExitLoop
			EndIf
		Else
			Sleep(100)
      EndIf

      If $isAbored = 1 Then
         ExitLoop
      EndIf
	WEnd
EndFunc

Func executeCommandSequenceTimer($Cmds)
   If $currentSerialIsConnected = False Then
      Return
   EndIf
   $currentCommandsList = $Cmds
   $currentCommandIndex = 1
   $currentLoopCounter = 0
   $isExecutionRunning = 1
   updateCurrentStatisticLabel()
   alignButtonState()
   ;_ArrayDisplay($Cmds, "seq")
   executeNextCommandFromSequence()
EndFunc

Func executeNextCommandFromSequence()
   If $isAbored = 0 Then
      If StringLeft($currentCommandsList[$currentCommandIndex], 1) = "#" Then
         Local $parts = StringSplit($currentCommandsList[$currentCommandIndex], '#~#', $STR_ENTIRESPLIT)
         ; [0] = size of the array...
         If UBound($parts) = 2 Then
            If $parts[1] = "#exit" Then
               ;$isAbored = 1
               $isAbored = 0
               $isExecutionRunning = 0
               alignButtonState()
               Return
            ElseIf $parts[1] = "#startnewlog" Then
               updateLogfileName()
            EndIf
         ElseIf UBound($parts) = 3 Then
            $part2Stripped = StringStripWS($parts[2], $STR_STRIPLEADING + $STR_STRIPTRAILING)
            If $parts[1] = "#waitfor" Then
               waitUntilYouGet($part2Stripped)
            ElseIf $parts[1] = "#sleep" Then
               Sleep($part2Stripped)
            ElseIf $parts[1] = "#writemarker" Then
               AppendLineLogFile(@CRLF & "##### MARKER ("&$markerNumber&") " & $part2Stripped & @CRLF)
               $markerNumber = $markerNumber + 1
            ElseIf $parts[1] = "#startnewlog" Then
               updateLogfileName($part2Stripped)
            EndIf
         Else
            _ArrayDisplay($parts, "ERROR in $parts")
         EndIf
      Else
         _CommSendString($currentCommandsList[$currentCommandIndex] & @CR)
         ReadSerialLineToEnd()
      EndIf

      ; prepare for next run
      $currentCommandIndex = $currentCommandIndex + 1
      If $currentCommandIndex >= UBound($currentCommandsList, 1) Then
         $currentCommandIndex = 1
         $currentLoopCounter = $currentLoopCounter +1
      EndIf

      updateCurrentStatisticLabel()

      ; loop event for next run
      GUICtrlSendToDummy($g_idUserDummy, 1)
   Else
      $isAbored = 0
      $isExecutionRunning = 0
      alignButtonState()
   EndIf
EndFunc

Func alignButtonState()
   If $currentSerialIsConnected = True Then
      GUICtrlSetState ($btnOpenSerial, $GUI_DISABLE)
      GUICtrlSetState ($btnCloseSerial, $GUI_ENABLE)
   Else
      GUICtrlSetState ($btnOpenSerial, $GUI_ENABLE)
      GUICtrlSetState ($btnCloseSerial, $GUI_DISABLE)
   EndIf

   If $isExecutionRunning = 1 Then
      GUICtrlSetState ($Edit1, $GUI_DISABLE)
      GUICtrlSetState ($btnLoadCommands, $GUI_DISABLE)
      GUICtrlSetState ($btnStartExecute, $GUI_DISABLE)
      GUICtrlSetState ($btnStopExecute, $GUI_ENABLE)
   Else
      GUICtrlSetState ($Edit1, $GUI_ENABLE)
      GUICtrlSetState ($btnLoadCommands, $GUI_ENABLE)
      If $currentSerialIsConnected = True Then
         GUICtrlSetState ($btnStartExecute, $GUI_ENABLE)
      Else
         GUICtrlSetState ($btnStartExecute, $GUI_DISABLE)
      EndIf
      GUICtrlSetState ($btnStopExecute, $GUI_DISABLE)
   EndIf
EndFunc

; button handler functions
Func btnOpenSerialFunc()
   setport() ;needed because a parameter is optional for setport so we can't use "setport" for the event
   GUICtrlSetState($Edit1, $GUI_FOCUS)
EndFunc

Func btnCloseSerialFunc()
   If $currentSerialIsConnected = True Then
      $isAbored = 1
      ; at this point it could be that we wait for somehting and already close the connection line?!
      _Commcloseport(true)
      $currentSerialIsConnected = False
      alignButtonState()
      GUICtrlSetData($lblSerialInfo, "--- closed ---")
   Else
      ;MsgBox($MB_SYSTEMMODAL, "", "WHY????")
   EndIf
EndFunc

Func btnNewLogFunc()
   updateLogfileName()
EndFunc

Func btnLoadCommandsFunc()
	Local $sFileOpenDialog = FileOpenDialog("Load commands", @ScriptDir & "\", "Commandsequence (*.txt)", $FD_FILEMUSTEXIST)
	If $sFileOpenDialog <> "" Then
      $fileContent = FileRead($sFileOpenDialog)
      GUICtrlSetData($Edit1, $fileContent)
	EndIf
EndFunc

Func btnSaveCommandsFunc()
   Local $sFileSaveDialog = FileSaveDialog("Save commands", @ScriptDir & "\", "Commandsequence (*.txt)", $FD_PATHMUSTEXIST)
   If @error Then
      MsgBox($MB_SYSTEMMODAL, "", "No file was saved.")
      Return False
   Else
      Local $sFileName = StringTrimLeft($sFileSaveDialog, StringInStr($sFileSaveDialog, "\", $STR_NOCASESENSEBASIC, -1))
      Local $iExtension = StringInStr($sFileName, ".", $STR_NOCASESENSEBASIC)
      If $iExtension Then
         If Not (StringTrimLeft($sFileName, $iExtension - 1) = ".txt") Then $sFileSaveDialog &= ".txt"
      Else
         $sFileSaveDialog &= ".txt"
      EndIf

      Local $hFileOpen = FileOpen($sFileSaveDialog, $FO_APPEND)
      If $hFileOpen = -1 Then
         MsgBox($MB_SYSTEMMODAL, "", "An error occurred whilst writing the temporary file.")
         Return False
      EndIf
      FileWrite($hFileOpen, GUICtrlRead($Edit1))
      Return True
   EndIf
EndFunc

Func btnStartExecuteFunc()
   If $currentSerialIsConnected = True Then
      Local $aRetArray[0], $aCleanedCommands[0]
      $aRetArray = StringSplit(GUICtrlRead($Edit1), @LF)
      ;_ArrayDisplay($aRetArray, "aRetArray=")

      For $j = 0 To UBound($aRetArray) - 1
         If StringStripWS($aRetArray[$j], $STR_STRIPLEADING + $STR_STRIPTRAILING) = "" Then
            ;_ArrayDelete($aRetArray, $j) ; no empty lines
         ElseIf StringLeft($aRetArray[$j], 2) = "##" Then
            ;_ArrayDelete($aRetArray, $j) ; no comments
         Else
            _ArrayAdd($aCleanedCommands, $aRetArray[$j])
         EndIf
      Next
      $isAbored = 0
      ;executeCommandSequence($aCleanedCommands)
      executeCommandSequenceTimer($aCleanedCommands)
   EndIf 
EndFunc

Func btnStopExecuteFunc()
   $isAbored = 1
EndFunc

; SetPort is a function taken from Comm example code + its includes, propably i somehow modified it, i dont remember what

; Function SetPort($mode=1)
; Creates a form for the port settings
;Parameter $mode sets the return value depending on whether the port was set
;Returns  0 if $mode <> 1
;          -1 If` the port not set and $mode is 1
Func SetPort($mode = 1);if $mode = 1 then returns -1 if settings not made
   Local $sportSetError
   Opt("GUIOnEventMode", 0) ;keep events for $Form2, use GuiGetMsg for $Form3

   #Region ### START Koda GUI section ### Form=d:\my documents\miscdelphi\commg\examplecommsetport.kxf
   $Form3 = GUICreate("COMMG Example - set Port", 422, 279, 329, 268, BitOR($WS_MINIMIZEBOX, $WS_CAPTION, $WS_POPUP, $WS_GROUP, $WS_BORDER, $WS_CLIPSIBLINGS, $DS_MODALFRAME), BitOR($WS_EX_TOPMOST, $WS_EX_WINDOWEDGE))
   $Group1 = GUICtrlCreateGroup("Set COM Port", 18, 8, 288, 252)
   $CmboPortsAvailable = GUICtrlCreateCombo("", 127, 28, 145, 25, BitOR($GUI_SS_DEFAULT_COMBO, $CBS_SORT))
   $CmBoBaud = GUICtrlCreateCombo("9600", 127, 66, 145, 25, BitOR($CBS_DROPDOWN, $CBS_AUTOHSCROLL, $CBS_SORT, $WS_VSCROLL))
   GUICtrlSetData(-1, "115200|10400|110|1200|128000|14400|150|15625|1800|19200|2000|2400|256000|28800|38400|3600|38400|4800|50|56000|57600|600|7200|75")
   GUICtrlSetData(-1, "115200")
   $CmBoStop = GUICtrlCreateCombo("1", 127, 141, 145, 25)
   GUICtrlSetData(-1, "1|2|1.5")
   $CmBoParity = GUICtrlCreateCombo("", 127, 178, 145, 25)

   ;GUICtrlSetData(-1, "odd|even|none|Mark|Space")
   GUICtrlSetData(-1, "0=None|1=Odd|2=Even|3=Mark|4=Space")
   GUICtrlSetData(-1, "0=None")
   $Label2 = GUICtrlCreateLabel("Port", 94, 32, 23, 17)
   $Label3 = GUICtrlCreateLabel("baud", 89, 70, 28, 17)
   $Label4 = GUICtrlCreateLabel("No. Stop bits", 52, 145, 65, 17)
   $Label5 = GUICtrlCreateLabel("parity", 88, 182, 29, 17)
   $CmboDataBits = GUICtrlCreateCombo("8", 127, 103, 145, 25)
   GUICtrlSetData(-1, "7|8")
   $Label7 = GUICtrlCreateLabel("No. of Data Bits", 38, 107, 79, 17)
   $ComboFlow = GUICtrlCreateCombo("NONE", 127, 216, 145, 25)
   GUICtrlSetData(-1, "NONE|XOnXOff|Hardware (RTS, CTS)")
   $Label1 = GUICtrlCreateLabel("flow control", 59, 220, 58, 17)
   GUICtrlCreateGroup("", -99, -99, 1, 1)
   $BtnApply = GUICtrlCreateButton("Apply", 315, 95, 75, 35, $BS_FLAT)
   GUICtrlSetFont(-1, 12, 400, 0, "MS Sans Serif")
   $BtnCancel = GUICtrlCreateButton("Cancel", 316, 147, 76, 35, $BS_FLAT)
   GUICtrlSetFont(-1, 12, 400, 0, "MS Sans Serif")
   GUISetState(@SW_SHOW)
   #EndRegion ### END Koda GUI section ###

   WinSetTitle($Form3, "", $setporttitle) ;ensure a change to Koda design doesn't stop script working
   $mainxy = WinGetPos($Form1)
   WinMove($Form3, "", $mainxy[0] + 20, $mainxy[1] + 20)

   $portlist = _CommListPorts(0) ;find the available COM ports and write them into the ports combo
   If @error = 1 Then
       MsgBox(0, 'trouble getting portlist', 'Program will terminate!')
       Exit
   EndIf

   For $pl = 1 To $portlist[0]
       $portnum = StringReplace($portlist[$pl], "COM", '')
       if StringLen($portnum) = 1 then $portnum = ' ' & $portnum
       $portlist[$pl] = 'COM' & $portnum
       GUICtrlSetData($CmboPortsAvailable, $portlist[$pl]);_CommListPorts())
   Next
   GUICtrlSetData($CmboPortsAvailable, $portlist[1]);show the first port found
   $setflow = 2;default to no flow control
   GUICtrlSetData($ComboFlow, $FlowType[$setflow])

   _GUICtrlComboBox_SetMinVisible($CmBoBaud, 10);restrict the length of the drop-down list

   $retval = 0

   While 1
       $msg = GUIGetMsg()
       If $msg = $BtnCancel Then
           If Not $mode Then $retval = -1
           ExitLoop
       EndIf

       If $msg = $BtnApply Then
           $comboflowsel = GUICtrlRead($ComboFlow)
           For $n = 0 To 2
               If $comboflowsel = $FlowType[$n] Then
                   $setflow = $n
                   ExitLoop
               EndIf

           Next
           $setport = StringReplace(GUICtrlRead($CmboPortsAvailable), 'COM', '')
           $setBaudrate = GUICtrlRead($CmBoBaud)
           $setDataBits = GUICtrlRead($CmboDataBits)
           $ParitySel = GUICtrlRead($CmBoParity)
           For $n = 0 To 4
               If $ParitySel = "0=None" Then
                   $SetParity = 0
                   ExitLoop
           ElseIf $ParitySel = "1=Odd" Then
              $SetParity = 1
                   ExitLoop
           ElseIf $ParitySel = "2=Even" Then
              $SetParity = 2
                   ExitLoop
           ElseIf $ParitySel = "3=Mark" Then
              $SetParity = 3
                   ExitLoop
           ElseIf $ParitySel = "4=Space" Then
              $SetParity = 4
                   ExitLoop
               EndIf
           Next

           $setStop = StringReplace(GUICtrlRead($CmBoStop), '.', '');replace 1.5 with 15 if needed

           $trySetPort = $setport
           $tryBautrate = GUICtrlRead($CmBoBaud)
           $tryDatabits = GUICtrlRead($CmboDataBits)
           $tryParity = $SetParity
           $tryStopbit = $setStop
           $tryFlowbit = $setflow

           $resOpen = _CommSetPort($trySetPort, $sportSetError, $tryBautrate, $tryDatabits, $tryParity, $tryStopbit, $tryFlowbit)
            ;$resOpen = _CommSetPort(3, $sportSetError, 115200, 8, 0, 1, 2)
            ;$resOpen = _CommSetPort(3, $sportSetError, $setBaudrate, $setDataBits, $SetParity, 1, 2)

           if $resOpen = 0 then
               MsgBox(0, 'Error port open COM=' & $setport, $sportSetError)
               Exit
           Else
               $currentSerialSetPort = $trySetPort
               $currentSerialBautrate = $tryBautrate
               $currentSerialDatabits = $tryDatabits
               $currentSerialParity = $tryParity
               $currentSerialStopbit = $tryStopbit
               $currentSerialFlowbit = $tryFlowbit
               $currentSerialIsConnected = True
               alignButtonState()
               updateCurrentSerialLabel()
           EndIf
           Sleep(100)
           ExitLoop
       EndIf

       ;stop user switching back to $form2
       If WinActive($maintitle) Then
           MsgBox(0, "main is active", "")
           If WinActivate($setporttitle) = 0 Then MsgBox(0, 'not found', $setporttitle)
       EndIf
   WEnd
   GUIDelete($Form3)
   WinActivate($maintitle)
   Opt("GUIOnEventMode", 1) ; reset the event mode to 1
   Return $retval
EndFunc   ;==>SetPort